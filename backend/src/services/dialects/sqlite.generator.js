/**
 * SQLite SQL Generator
 * Enhanced version with support for additional features
 */

/**
 * Generate a header comment for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Header comment
 */
exports.headerComment = (schema) => {
  return `-- SQLite Script Generated for Schema: ${schema.name}
-- Created: ${new Date().toISOString()}
-- Description: ${schema.description || 'Database schema generated by LaymanDB'}

-- Enable foreign key constraints
PRAGMA foreign_keys = ON;

-- Set synchronous mode for better durability
PRAGMA synchronous = NORMAL;

-- Set journal mode for better concurrency
PRAGMA journal_mode = WAL;`;
};

/**
 * Generate DROP statements for all tables to allow re-running the script
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of DROP TABLE statements
 */
exports.generateDropStatements = (schema) => {
  return [`-- Drop tables if they exist (for easier script re-running)
${schema.tables.map(table => `DROP TABLE IF EXISTS "${table.name}";`).join('\n')}`];
};

/**
 * Generate CREATE TABLE statement for SQLite
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {string} - CREATE TABLE statement
 */
exports.createTableStatement = (table, schema) => {
  // Map MySQL data types to SQLite
  const mappedColumns = table.columns.map(column => ({
    ...column,
    dataType: mapDataType(column.dataType)
  }));
  
  const columnDefinitions = mappedColumns.map(column => {
    let definition = `"${column.name}" ${column.dataType}`;
    
    if (column.isNullable === false) {
      definition += ' NOT NULL';
    }
    
    if (column.defaultValue) {
      definition += ` DEFAULT ${formatDefaultValue(column.defaultValue, column.dataType)}`;
    }
    
    if (column.isPrimaryKey && !isCompositePrimaryKey(table)) {
      definition += ' PRIMARY KEY';
      
      // Auto-increment for INTEGER primary keys
      if (column.dataType.toUpperCase() === 'INTEGER') {
        definition += ' AUTOINCREMENT';
      }
    }
    
    return definition;
  });
  
  // Handle composite primary keys
  const primaryKeyColumns = table.columns.filter(column => column.isPrimaryKey);
  if (primaryKeyColumns.length > 1) {
    const pkDefinition = `PRIMARY KEY (${primaryKeyColumns.map(col => `"${col.name}"`).join(', ')})`;
    columnDefinitions.push(pkDefinition);
  }
  
  // Foreign key constraints - SQLite supports them at table creation
  const foreignKeys = table.columns.filter(column => column.isForeignKey && column.references);
  foreignKeys.forEach(column => {
    let constraint = `FOREIGN KEY ("${column.name}") REFERENCES "${column.references.table}" ("${column.references.column}")`;
    
    if (column.references.onDelete) {
      constraint += ` ON DELETE ${column.references.onDelete}`;
    }
    
    if (column.references.onUpdate) {
      constraint += ` ON UPDATE ${column.references.onUpdate}`;
    }
    
    columnDefinitions.push(constraint);
  });
  
  // Unique constraints
  const uniqueColumns = table.columns.filter(column => column.isUnique && !column.isPrimaryKey);
  uniqueColumns.forEach(column => {
    columnDefinitions.push(`UNIQUE ("${column.name}")`);
  });
  
  // Create the table definition
  const tableDefinition = `-- Table: ${table.name}${table.isWeakEntity ? ' (Weak Entity)' : ''}${table.isLookupTable ? ' (Lookup Table)' : ''}${table.isJunctionTable ? ' (Junction Table)' : ''}
CREATE TABLE IF NOT EXISTS "${table.name}" (
  ${columnDefinitions.join(',\n  ')}
);`;
  
  // Create statements to add metadata for table and column descriptions
  const metadataStatements = [];
  
  if (table.description) {
    metadataStatements.push(`-- Add table description
INSERT OR REPLACE INTO "schema_metadata" ("object_type", "object_name", "description") 
VALUES ('table', '${table.name}', '${escapeString(table.description)}');`);
  }
  
  // Add column descriptions
  mappedColumns.forEach(column => {
    if (column.description) {
      metadataStatements.push(`-- Add column description
INSERT OR REPLACE INTO "schema_metadata" ("object_type", "object_name", "description") 
VALUES ('column', '${table.name}.${column.name}', '${escapeString(column.description)}');`);
    }
  });
  
  return tableDefinition + (metadataStatements.length > 0 ? '\n\n' + metadataStatements.join('\n') : '');
};

/**
 * Generate CREATE INDEX statements for SQLite
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {Array} - CREATE INDEX statements
 */
exports.createIndexStatements = (table, schema) => {
  const indexes = [];
  
  // Create metadata table for comments (only once)
  if (table === schema.tables[0]) {
    indexes.unshift(`-- Create metadata table for schema documentation
CREATE TABLE IF NOT EXISTS "schema_metadata" (
  "object_type" TEXT NOT NULL,
  "object_name" TEXT NOT NULL,
  "description" TEXT,
  PRIMARY KEY ("object_type", "object_name")
);

-- Create index on metadata table
CREATE INDEX IF NOT EXISTS "idx_schema_metadata_type" ON "schema_metadata" ("object_type");
CREATE INDEX IF NOT EXISTS "idx_schema_metadata_name" ON "schema_metadata" ("object_name");`);
  }
  
  // Add indexes for foreign keys
  const foreignKeyColumns = table.columns.filter(column => column.isForeignKey);
  
  foreignKeyColumns.forEach(column => {
    // Skip if the column is already part of the primary key
    if (!column.isPrimaryKey) {
      indexes.push(`-- Index for foreign key: ${column.name}
CREATE INDEX IF NOT EXISTS "idx_${table.name}_${column.name}" ON "${table.name}" ("${column.name}");`);
    }
  });
  
  // Add indexes for frequently queried columns
  const potentialIndexColumns = table.columns.filter(col => 
    // Skip columns that already have indexes
    !col.isPrimaryKey && 
    !col.isForeignKey && 
    !col.isUnique &&
    // Target columns likely to be used in WHERE clauses or for sorting
    (col.name.includes('status') || 
     col.name.includes('type') || 
     col.name.includes('date') || 
     col.name.includes('code') ||
     col.name.includes('category') ||
     col.name === 'name' ||
     col.name === 'email')
  );
  
  potentialIndexColumns.forEach(column => {
    indexes.push(`-- Index for commonly queried column: ${column.name}
CREATE INDEX IF NOT EXISTS "idx_${table.name}_${column.name}" ON "${table.name}" ("${column.name}");`);
  });
  
  return indexes;
};

/**
 * Generate ALTER TABLE statement for adding foreign key
 * SQLite doesn't support ALTER TABLE ADD CONSTRAINT, so this returns a warning comment
 * @param {string} tableName - Table name
 * @param {Object} foreignKey - Foreign key constraint
 * @returns {string} - Comment indicating limitation
 */
exports.addForeignKeyStatement = (tableName, foreignKey) => {
  return `-- Note: SQLite doesn't support ALTER TABLE ADD CONSTRAINT for foreign keys
-- Foreign keys must be defined in the CREATE TABLE statement
-- To add a foreign key constraint, you need to recreate the table with the constraint`;
};

/**
 * Generate CREATE VIEW statements for SQLite
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of CREATE VIEW statements
 */
exports.createViewStatements = (schema) => {
  const views = [];
  
  // Find tables with typical view potential (e.g., join opportunities)
  const tablesWithRelationships = new Set();
  
  // Collect tables involved in relationships
  schema.relationships.forEach(rel => {
    tablesWithRelationships.add(rel.sourceTable);
    tablesWithRelationships.add(rel.targetTable);
  });
  
  // Generate views for tables with many relationships
  Array.from(tablesWithRelationships).forEach(tableName => {
    const table = schema.tables.find(t => t.name === tableName);
    if (!table) return;
    
    // Find all direct relationships for this table
    const relations = schema.relationships.filter(rel => 
      rel.sourceTable === tableName || rel.targetTable === tableName
    );
    
    // Skip if not enough relationships
    if (relations.length < 2) return;
    
    // Create a view that joins this table with its related tables
    const joinClauses = [];
    const selectColumns = [`t."${table.columns.map(c => c.name).join('", t."')}"`];
    
    relations.forEach((rel, idx) => {
      const isSource = rel.sourceTable === tableName;
      const relatedTableName = isSource ? rel.targetTable : rel.sourceTable;
      const relatedTable = schema.tables.find(t => t.name === relatedTableName);
      
      if (!relatedTable) return;
      
      const alias = `r${idx + 1}`;
      
      // Skip junction tables for the view to keep it simpler
      if (relatedTable.isJunctionTable) return;
      
      // Add join clause
      if (isSource) {
        // This table to related table
        joinClauses.push(`LEFT JOIN "${relatedTableName}" ${alias} ON t."${rel.sourceColumn}" = ${alias}."${rel.targetColumn}"`);
      } else {
        // Related table to this table
        joinClauses.push(`LEFT JOIN "${relatedTableName}" ${alias} ON ${alias}."${rel.sourceColumn}" = t."${rel.targetColumn}"`);
      }
      
      // Add columns from related table, except for the join key to avoid duplication
      const relatedColumns = relatedTable.columns
        .filter(c => !(isSource && c.name === rel.targetColumn) && 
                    !(!isSource && c.name === rel.sourceColumn))
        .map(c => `${alias}."${c.name}" AS "${relatedTableName}_${c.name}"`);
      
      selectColumns.push(...relatedColumns);
    });
    
    // Skip if no joins were created
    if (joinClauses.length === 0) return;
    
    // Create the view
    views.push(`-- View for ${tableName} with related data
CREATE VIEW IF NOT EXISTS "v_${tableName}_details" AS
SELECT 
  ${selectColumns.join(',\n  ')}
FROM "${tableName}" t
${joinClauses.join('\n')};

-- Add view description
INSERT OR REPLACE INTO "schema_metadata" ("object_type", "object_name", "description") 
VALUES ('view', 'v_${tableName}_details', 'Detailed view for ${tableName} with joined related data');`);
  });
  
  return views;
};

/**
 * Generate seed data for lookup tables
 * @param {Object} table - Table object
 * @returns {Array} - Array of INSERT statements
 */
exports.generateSeedData = (table) => {
  // Only generate seed data for lookup tables
  if (!table.isLookupTable) return [];
  
  // Prepare the insert statement
  let insertStatement = `-- Seed data for lookup table: ${table.name}\nINSERT INTO "${table.name}" (`;
  
  // Find column names, excluding auto-increment primary keys and timestamps
  const columns = table.columns.filter(col => 
    !(col.isPrimaryKey && col.dataType.toUpperCase() === 'INTEGER' && col.name === 'id') &&
    col.name !== 'created_at' && 
    col.name !== 'updated_at'
  );
  
  // If no suitable columns found, return empty array
  if (columns.length === 0) return [];
  
  // Add column names
  insertStatement += columns.map(col => `"${col.name}"`).join(', ');
  insertStatement += ') VALUES\n';
  
  // Generate example values based on table name and column types
  const values = [];
  
  // Determine the type of lookup table and generate appropriate data
  if (table.name.includes('status')) {
    values.push(generateValuesList(columns, ['Active', 'Inactive', 'Pending', 'Completed', 'Cancelled']));
  } else if (table.name.includes('type')) {
    values.push(generateValuesList(columns, ['Standard', 'Premium', 'Basic', 'Custom', 'Enterprise']));
  } else if (table.name.includes('category')) {
    values.push(generateValuesList(columns, ['General', 'Electronics', 'Clothing', 'Food', 'Services']));
  } else if (table.name.includes('priority')) {
    values.push(generateValuesList(columns, ['Low', 'Medium', 'High', 'Critical', 'Urgent']));
  } else if (table.name.includes('role')) {
    values.push(generateValuesList(columns, ['Admin', 'User', 'Manager', 'Guest', 'SuperAdmin']));
  } else {
    // Generic lookup table with sequential values
    values.push(generateValuesList(columns, ['Value 1', 'Value 2', 'Value 3', 'Value 4', 'Value 5']));
  }
  
  // Add values
  insertStatement += values.join(',\n');
  insertStatement += ';';
  
  return [insertStatement];
};

/**
 * Generate a list of values for INSERT statement
 * @param {Array} columns - Columns to generate values for
 * @param {Array} names - Example names to use
 * @returns {string} - VALUES clause for INSERT statement
 */
function generateValuesList(columns, names) {
  const rows = [];
  
  names.forEach((name, idx) => {
    const values = columns.map(col => {
      if (col.name === 'name' || col.name === 'label' || col.name === 'title') {
        return `'${escapeString(name)}'`;
      } else if (col.name === 'code' || col.name === 'key') {
        return `'${name.substring(0, 3).toUpperCase()}'`;
      } else if (col.name === 'value' || col.name === 'id') {
        return idx + 1;
      } else if (col.name === 'description') {
        return `'${escapeString(name)} description'`;
      } else if (col.name === 'is_active' || col.name === 'active') {
        return '1';
      } else if (col.name === 'display_order' || col.name === 'sort_order') {
        return idx + 1;
      } else if (col.dataType.toUpperCase().includes('INT')) {
        return idx + 1;
      } else {
        return `'Value ${idx + 1}'`;
      }
    });
    
    rows.push(`(${values.join(', ')})`);
  });
  
  return rows.join(',\n');
}

/**
 * Generate footer for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Footer comment
 */
exports.footerComment = (schema) => {
  return `-- Script execution completed
-- Schema: ${schema.name}
-- Tables: ${schema.tables.length}`;
};

/**
 * Format default value for SQLite
 * @param {string} value - Default value
 * @param {string} dataType - Column data type
 * @returns {string} - Formatted default value
 */
function formatDefaultValue(value, dataType) {
  if (value === 'CURRENT_TIMESTAMP' || value === 'NOW()') {
    return "CURRENT_TIMESTAMP";
  } else if (value === 'NULL') {
    return 'NULL';
  } else if (dataType && (
      dataType.toUpperCase().includes('INT') || 
      dataType.toUpperCase().includes('REAL')
    ) && !isNaN(value)) {
    // For numeric types, don't quote numeric values
    return value;
  }
  
  // For all other cases, quote the value
  return `'${escapeString(value)}'`;
}

/**
 * Escape string for SQLite
 * @param {string} str - String to escape
 * @returns {string} - Escaped string
 */
function escapeString(str) {
  if (typeof str !== 'string') return str;
  return str.replace(/'/g, "''");
}

/**
 * Check if table has composite primary key
 * @param {Object} table - Table object
 * @returns {boolean} - True if table has composite primary key
 */
function isCompositePrimaryKey(table) {
  return table.columns.filter(column => column.isPrimaryKey).length > 1;
}

/**
 * Map MySQL data types to SQLite data types
 * @param {string} dataType - MySQL data type
 * @returns {string} - SQLite data type
 */
function mapDataType(dataType) {
  // SQLite has only 5 storage classes: NULL, INTEGER, REAL, TEXT, and BLOB
  const typeMap = {
    'INT': 'INTEGER',
    'INTEGER': 'INTEGER',
    'TINYINT': 'INTEGER',
    'SMALLINT': 'INTEGER',
    'MEDIUMINT': 'INTEGER',
    'BIGINT': 'INTEGER',
    'FLOAT': 'REAL',
    'DOUBLE': 'REAL',
    'DECIMAL': 'REAL',
    'CHAR': 'TEXT',
    'VARCHAR': 'TEXT',
    'TEXT': 'TEXT',
    'TINYTEXT': 'TEXT',
    'MEDIUMTEXT': 'TEXT',
    'LONGTEXT': 'TEXT',
    'BOOLEAN': 'INTEGER', // SQLite doesn't have a dedicated boolean type
    'DATE': 'TEXT',
    'DATETIME': 'TEXT',
    'TIMESTAMP': 'TEXT',
    'TIME': 'TEXT',
    'YEAR': 'INTEGER',
    'BLOB': 'BLOB',
    'TINYBLOB': 'BLOB',
    'MEDIUMBLOB': 'BLOB',
    'LONGBLOB': 'BLOB',
    'ENUM': 'TEXT',
    'SET': 'TEXT',
    'JSON': 'TEXT',  // SQLite doesn't have a native JSON type
    'UUID': 'TEXT'   // SQLite doesn't have a native UUID type
  };
  
  // Extract type and ignore size (SQLite doesn't use size constraints)
  const match = dataType.match(/^(\w+)(?:\(([^)]+)\))?$/);
  if (!match) return 'TEXT'; // Default to TEXT for unknown types
  
  const type = match[1].toUpperCase();
  
  // Map the type, defaulting to TEXT
  return typeMap[type] || 'TEXT';
}

module.exports = exports;
