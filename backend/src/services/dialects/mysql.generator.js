/**
 * MySQL SQL Generator
 * Enhanced version with support for additional features
 */

/**
 * Generate a header comment for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Header comment
 */
exports.headerComment = (schema) => {
  return `-- MySQL Script Generated for Schema: ${schema.name}
-- Created: ${new Date().toISOString()}
-- Description: ${schema.description || 'Database schema generated by LaymanDB'}

-- Disable foreign key checks temporarily for easier table creation/modification
SET FOREIGN_KEY_CHECKS=0;

-- Create database if it doesn't exist
CREATE DATABASE IF NOT EXISTS \`${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}\`;

-- Use the database
USE \`${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}\`;`;
};

/**
 * Generate DROP statements for all tables to allow re-running the script
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of DROP TABLE statements
 */
exports.generateDropStatements = (schema) => {
  return [`-- Drop tables if they exist (for easier script re-running)
${schema.tables.map(table => `DROP TABLE IF EXISTS \`${table.name}\`;`).join('\n')}`];
};

/**
 * Generate CREATE TABLE statement for MySQL
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {string} - CREATE TABLE statement
 */
exports.createTableStatement = (table, schema) => {
  const columnDefinitions = table.columns.map(column => {
    let definition = `\`${column.name}\` ${mapDataType(column.dataType)}`;
    
    // Handle auto-increment for primary key
    if (column.isPrimaryKey && 
        !isCompositePrimaryKey(table) && 
        ['INT', 'INTEGER', 'BIGINT', 'SMALLINT', 'TINYINT', 'MEDIUMINT']
          .some(type => column.dataType.toUpperCase().includes(type))) {
      definition += ' AUTO_INCREMENT';
    }
    
    if (column.isNullable === false) {
      definition += ' NOT NULL';
    } else {
      definition += ' NULL';
    }
    
    if (column.defaultValue) {
      definition += ` DEFAULT ${formatDefaultValue(column.defaultValue, column.dataType)}`;
    }
    
    if (column.isUnique && !column.isPrimaryKey) {
      definition += ' UNIQUE';
    }
    
    if (column.isPrimaryKey && !isCompositePrimaryKey(table)) {
      definition += ' PRIMARY KEY';
    }
    
    // MySQL supports inline foreign key constraints
    if (column.isForeignKey && column.references) {
      definition += ` REFERENCES \`${column.references.table}\`(\`${column.references.column}\`)`;
      
      if (column.references.onDelete) {
        definition += ` ON DELETE ${column.references.onDelete}`;
      }
      
      if (column.references.onUpdate) {
        definition += ` ON UPDATE ${column.references.onUpdate}`;
      }
    }
    
    if (column.description) {
      definition += ` COMMENT '${column.description.replace(/'/g, "''")}'`;
    }
    
    return definition;
  });
  
  // Handle composite primary keys
  const primaryKeyColumns = table.columns.filter(column => column.isPrimaryKey);
  if (primaryKeyColumns.length > 1) {
    const pkDefinition = `PRIMARY KEY (${primaryKeyColumns.map(col => `\`${col.name}\``).join(', ')})`;
    columnDefinitions.push(pkDefinition);
  }
  
  // Handle foreign keys that are not defined inline
  const foreignKeyConstraints = table.columns
    .filter(column => column.isForeignKey && column.references)
    .map(column => {
      return `CONSTRAINT \`fk_${table.name}_${column.name}\` FOREIGN KEY (\`${column.name}\`) 
    REFERENCES \`${column.references.table}\`(\`${column.references.column}\`)
    ON DELETE ${column.references.onDelete || 'NO ACTION'} 
    ON UPDATE ${column.references.onUpdate || 'NO ACTION'}`;
    });
  
  if (foreignKeyConstraints.length > 0) {
    columnDefinitions.push(...foreignKeyConstraints);
  }
  
  // Generate table options
  let tableOptions = "ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci";
  
  // Add table comment if description exists
  if (table.description) {
    tableOptions += ` COMMENT='${table.description.replace(/'/g, "''")}'`;
  }
  
  return `-- Table: ${table.name}${table.isWeakEntity ? ' (Weak Entity)' : ''}${table.isLookupTable ? ' (Lookup Table)' : ''}${table.isJunctionTable ? ' (Junction Table)' : ''}
CREATE TABLE IF NOT EXISTS \`${table.name}\` (
  ${columnDefinitions.join(',\n  ')}
) ${tableOptions};`;
};

/**
 * Generate CREATE INDEX statements for MySQL
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {Array} - CREATE INDEX statements
 */
exports.createIndexStatements = (table, schema) => {
  const indexes = [];
  
  // Add indexes for foreign keys
  const foreignKeyColumns = table.columns.filter(column => column.isForeignKey);
  
  foreignKeyColumns.forEach(column => {
    // Skip if the column is already part of the primary key
    if (!column.isPrimaryKey) {
      indexes.push(`-- Index for foreign key: ${column.name}
CREATE INDEX \`idx_${table.name}_${column.name}\` ON \`${table.name}\` (\`${column.name}\`);`);
    }
  });
  
  // Add indexes for frequently queried columns (heuristic-based)
  const potentialIndexColumns = table.columns.filter(column => 
    // Skip columns that already have indexes
    !column.isPrimaryKey && 
    !column.isForeignKey && 
    !column.isUnique &&
    // Target columns likely to be used in WHERE clauses or for sorting
    (column.name.includes('status') || 
     column.name.includes('type') || 
     column.name.includes('date') || 
     column.name.includes('code') ||
     column.name.includes('category') ||
     column.name === 'name' ||
     column.name === 'email')
  );
  
  potentialIndexColumns.forEach(column => {
    indexes.push(`-- Index for commonly queried column: ${column.name}
CREATE INDEX \`idx_${table.name}_${column.name}\` ON \`${table.name}\` (\`${column.name}\`);`);
  });
  
  return indexes;
};

/**
 * Generate ALTER TABLE statement for adding foreign key
 * @param {string} tableName - Table name
 * @param {Object} foreignKey - Foreign key constraint
 * @returns {string} - ALTER TABLE statement
 */
exports.addForeignKeyStatement = (tableName, foreignKey) => {
  return `ALTER TABLE \`${tableName}\`
ADD CONSTRAINT \`${foreignKey.constraintName || `fk_${tableName}_${foreignKey.columnName}`}\`
FOREIGN KEY (\`${foreignKey.columnName}\`)
REFERENCES \`${foreignKey.referenceTable}\`(\`${foreignKey.referenceColumn}\`)
ON DELETE ${foreignKey.onDelete}
ON UPDATE ${foreignKey.onUpdate};`;
};

/**
 * Generate CREATE VIEW statements for commonly needed views
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of CREATE VIEW statements
 */
exports.createViewStatements = (schema) => {
  const views = [];
  
  // Find tables with typical view potential (e.g., join opportunities)
  const tablesWithRelationships = new Set();
  
  // Collect tables involved in relationships
  schema.relationships.forEach(rel => {
    tablesWithRelationships.add(rel.sourceTable);
    tablesWithRelationships.add(rel.targetTable);
  });
  
  // Generate views for tables with many relationships
  Array.from(tablesWithRelationships).forEach(tableName => {
    const table = schema.tables.find(t => t.name === tableName);
    if (!table) return;
    
    // Find all direct relationships for this table
    const relations = schema.relationships.filter(rel => 
      rel.sourceTable === tableName || rel.targetTable === tableName
    );
    
    // Skip if not enough relationships
    if (relations.length < 2) return;
    
    // Create a view that joins this table with its related tables
    const joinClauses = [];
    const selectColumns = [`t.\`${table.columns.map(c => c.name).join('\`, t.\`')}\``];
    
    relations.forEach((rel, idx) => {
      const isSource = rel.sourceTable === tableName;
      const relatedTableName = isSource ? rel.targetTable : rel.sourceTable;
      const relatedTable = schema.tables.find(t => t.name === relatedTableName);
      
      if (!relatedTable) return;
      
      const alias = `r${idx + 1}`;
      
      // Skip junction tables for the view to keep it simpler
      if (relatedTable.isJunctionTable) return;
      
      // Add join clause
      if (isSource) {
        // This table to related table
        joinClauses.push(`LEFT JOIN \`${relatedTableName}\` ${alias} ON t.\`${rel.sourceColumn}\` = ${alias}.\`${rel.targetColumn}\``);
      } else {
        // Related table to this table
        joinClauses.push(`LEFT JOIN \`${relatedTableName}\` ${alias} ON ${alias}.\`${rel.sourceColumn}\` = t.\`${rel.targetColumn}\``);
      }
      
      // Add columns from related table, except for the join key to avoid duplication
      const relatedColumns = relatedTable.columns
        .filter(c => !(isSource && c.name === rel.targetColumn) && 
                    !(!isSource && c.name === rel.sourceColumn))
        .map(c => `${alias}.\`${c.name}\` AS \`${relatedTableName}_${c.name}\``);
      
      selectColumns.push(...relatedColumns);
    });
    
    // Skip if no joins were created
    if (joinClauses.length === 0) return;
    
    // Create the view
    views.push(`-- View for ${tableName} with related data
CREATE OR REPLACE VIEW \`v_${tableName}_details\` AS
SELECT 
  ${selectColumns.join(',\n  ')}
FROM \`${tableName}\` t
${joinClauses.join('\n')};`);
  });
  
  return views;
};

/**
 * Generate MySQL triggers for automatic timestamp updates
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of CREATE TRIGGER statements
 */
exports.createTriggerStatements = (schema) => {
  const triggers = [];
  
  schema.tables.forEach(table => {
    // Check if the table has updated_at column
    const hasUpdatedAt = table.columns.some(col => col.name === 'updated_at');
    
    if (hasUpdatedAt) {
      triggers.push(`-- Trigger for automatic updated_at timestamp on ${table.name}
DELIMITER //
CREATE TRIGGER \`trig_${table.name}_update_timestamp\`
BEFORE UPDATE ON \`${table.name}\`
FOR EACH ROW
BEGIN
  SET NEW.updated_at = CURRENT_TIMESTAMP;
END //
DELIMITER ;`);
    }
  });
  
  return triggers;
};

/**
 * Generate seed data for lookup tables
 * @param {Object} table - Table object
 * @returns {Array} - Array of INSERT statements
 */
exports.generateSeedData = (table) => {
  // Only generate seed data for lookup tables
  if (!table.isLookupTable) return [];
  
  // Prepare the insert statement
  let insertStatement = `-- Seed data for lookup table: ${table.name}\nINSERT INTO \`${table.name}\` (`;
  
  // Find column names, excluding auto-increment primary keys and timestamps
  const columns = table.columns.filter(col => 
    !(col.isPrimaryKey && col.dataType.toUpperCase().includes('INT')) &&
    col.name !== 'created_at' && 
    col.name !== 'updated_at'
  );
  
  // If no suitable columns found, return empty array
  if (columns.length === 0) return [];
  
  // Add column names
  insertStatement += columns.map(col => `\`${col.name}\``).join(', ');
  insertStatement += ') VALUES\n';
  
  // Generate example values based on table name and column types
  const values = [];
  
  // Determine the type of lookup table and generate appropriate data
  if (table.name.includes('status')) {
    values.push(generateValuesList(columns, ['Active', 'Inactive', 'Pending', 'Completed', 'Cancelled']));
  } else if (table.name.includes('type')) {
    values.push(generateValuesList(columns, ['Standard', 'Premium', 'Basic', 'Custom', 'Enterprise']));
  } else if (table.name.includes('category')) {
    values.push(generateValuesList(columns, ['General', 'Electronics', 'Clothing', 'Food', 'Services']));
  } else if (table.name.includes('priority')) {
    values.push(generateValuesList(columns, ['Low', 'Medium', 'High', 'Critical', 'Urgent']));
  } else if (table.name.includes('role')) {
    values.push(generateValuesList(columns, ['Admin', 'User', 'Manager', 'Guest', 'SuperAdmin']));
  } else {
    // Generic lookup table with sequential values
    values.push(generateValuesList(columns, ['Value 1', 'Value 2', 'Value 3', 'Value 4', 'Value 5']));
  }
  
  // Add values
  insertStatement += values.join(',\n');
  insertStatement += ';';
  
  return [insertStatement];
};

/**
 * Generate a list of values for INSERT statement
 * @param {Array} columns - Columns to generate values for
 * @param {Array} names - Example names to use
 * @returns {string} - VALUES clause for INSERT statement
 */
function generateValuesList(columns, names) {
  const rows = [];
  
  names.forEach((name, idx) => {
    const values = columns.map(col => {
      if (col.name === 'name' || col.name === 'label' || col.name === 'title') {
        return `'${name}'`;
      } else if (col.name === 'code' || col.name === 'key') {
        return `'${name.substring(0, 3).toUpperCase()}'`;
      } else if (col.name === 'value' || col.name === 'id') {
        return idx + 1;
      } else if (col.name === 'description') {
        return `'${name} description'`;
      } else if (col.name === 'is_active' || col.name === 'active') {
        return '1';
      } else if (col.name === 'display_order' || col.name === 'sort_order') {
        return idx + 1;
      } else if (col.dataType.toUpperCase().includes('INT')) {
        return idx + 1;
      } else {
        return `'Value ${idx + 1}'`;
      }
    });
    
    rows.push(`(${values.join(', ')})`);
  });
  
  return rows.join(',\n');
}

/**
 * Generate footer for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Footer comment
 */
exports.footerComment = (schema) => {
  return `-- Re-enable foreign key checks
SET FOREIGN_KEY_CHECKS=1;

-- Script execution completed
-- Schema: ${schema.name}
-- Tables: ${schema.tables.length}`;
};

/**
 * Format default value for MySQL
 * @param {string} value - Default value
 * @param {string} dataType - Column data type
 * @returns {string} - Formatted default value
 */
function formatDefaultValue(value, dataType) {
  if (value === 'CURRENT_TIMESTAMP' || value === 'NOW()') {
    return 'CURRENT_TIMESTAMP';
  } else if (value === 'NULL') {
    return 'NULL';
  } else if (dataType && (
      dataType.toUpperCase().includes('INT') || 
      dataType.toUpperCase().includes('FLOAT') || 
      dataType.toUpperCase().includes('DOUBLE') || 
      dataType.toUpperCase().includes('DECIMAL')
    ) && !isNaN(value)) {
    // For numeric types, don't quote numeric values
    return value;
  }
  
  // For all other cases, quote the value
  return `'${value.replace(/'/g, "''")}'`;
}

/**
 * Check if table has composite primary key
 * @param {Object} table - Table object
 * @returns {boolean} - True if table has composite primary key
 */
function isCompositePrimaryKey(table) {
  return table.columns.filter(column => column.isPrimaryKey).length > 1;
}

/**
 * Map data type to ensure MySQL compatibility
 * @param {string} dataType - Data type to map
 * @returns {string} - Mapped data type
 */
function mapDataType(dataType) {
  if (!dataType) return 'VARCHAR(255)';
  
  // If already has precision/scale specified, return as is
  if (dataType.includes('(')) return dataType;
  
  // Map data types that need default precision/scale
  const upperType = dataType.toUpperCase();
  
  if (upperType === 'VARCHAR') return 'VARCHAR(255)';
  if (upperType === 'CHAR') return 'CHAR(50)';
  if (upperType === 'DECIMAL') return 'DECIMAL(10,2)';
  if (upperType === 'FLOAT') return 'FLOAT(10,2)';
  
  return dataType;
}

module.exports = exports;
