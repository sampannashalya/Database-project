/**
 * PostgreSQL SQL Generator
 * Enhanced version with support for additional features
 */

/**
 * Generate a header comment for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Header comment
 */
exports.headerComment = (schema) => {
  return `-- PostgreSQL Script Generated for Schema: ${schema.name}
-- Created: ${new Date().toISOString()}
-- Description: ${schema.description || 'Database schema generated by LaymanDB'}

-- Start transaction
BEGIN;

-- Create schema if it doesn't exist
CREATE SCHEMA IF NOT EXISTS "${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}";

-- Set search path
SET search_path TO "${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}", public;`;
};

/**
 * Generate DROP statements for all tables to allow re-running the script
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of DROP TABLE statements
 */
exports.generateDropStatements = (schema) => {
  return [`-- Drop tables if they exist (for easier script re-running)
${schema.tables.map(table => `DROP TABLE IF EXISTS "${table.name}" CASCADE;`).join('\n')}`];
};

/**
 * Generate PostgreSQL enum types based on lookup tables
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of CREATE TYPE statements
 */
exports.generateEnumTypes = (schema) => {
  const enumTypes = [];
  
  // Find lookup tables that are good candidates for enum types
  const lookupTables = schema.tables.filter(table => 
    table.isLookupTable && 
    table.columns.some(col => col.name === 'name' || col.name === 'value')
  );
  
  lookupTables.forEach(table => {
    // Skip tables with many columns (not good enum candidates)
    const nonSystemColumns = table.columns.filter(col => 
      !['id', 'created_at', 'updated_at'].includes(col.name)
    );
    
    if (nonSystemColumns.length > 3) return;
    
    // Create enum type name from table name
    const enumName = `${table.name.toLowerCase()}_enum`;
    
    // We would need sample values from lookup tables to create proper enums
    // Here we'll just create a placeholder comment
    enumTypes.push(`-- Consider creating an enum type for ${table.name}
-- Example: CREATE TYPE ${enumName} AS ENUM ('value1', 'value2', 'value3');

-- For reference, this would be the table structure:
-- Table: ${table.name}
-- Columns: ${nonSystemColumns.map(col => col.name).join(', ')}`);
  });
  
  return enumTypes;
};

/**
 * Generate CREATE TABLE statement for PostgreSQL
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {string} - CREATE TABLE statement
 */
exports.createTableStatement = (table, schema) => {
  // Map MySQL data types to PostgreSQL
  const mappedColumns = table.columns.map(column => ({
    ...column,
    dataType: mapDataType(column.dataType)
  }));
  
  const columnDefinitions = mappedColumns.map(column => {
    let definition = `"${column.name}" ${column.dataType}`;
    
    // Handle auto-increment/sequences for primary keys
    if (column.isPrimaryKey && 
        !isCompositePrimaryKey(table) && 
        ['INTEGER', 'BIGINT', 'SMALLINT'].includes(column.dataType.toUpperCase())) {
      
      // Use SERIAL types for auto-increment in PostgreSQL
      if (column.dataType.toUpperCase() === 'INTEGER') {
        definition = `"${column.name}" SERIAL`;
      } else if (column.dataType.toUpperCase() === 'BIGINT') {
        definition = `"${column.name}" BIGSERIAL`;
      } else if (column.dataType.toUpperCase() === 'SMALLINT') {
        definition = `"${column.name}" SMALLSERIAL`;
      }
    }
    
    if (column.isNullable === false) {
      definition += ' NOT NULL';
    } else {
      definition += ' NULL';
    }
    
    if (column.defaultValue) {
      definition += ` DEFAULT ${formatDefaultValue(column.defaultValue, column.dataType)}`;
    }
    
    if (column.isPrimaryKey && !isCompositePrimaryKey(table)) {
      definition += ' PRIMARY KEY';
    }
    
    return definition;
  });
  
  // Handle composite primary keys
  const primaryKeyColumns = table.columns.filter(column => column.isPrimaryKey);
  if (primaryKeyColumns.length > 1) {
    const pkDefinition = `PRIMARY KEY (${primaryKeyColumns.map(col => `"${col.name}"`).join(', ')})`;
    columnDefinitions.push(pkDefinition);
  }
  
  // Foreign key constraints
  const foreignKeys = table.columns.filter(column => column.isForeignKey && column.references);
  foreignKeys.forEach(column => {
    const fkDefinition = `CONSTRAINT "fk_${table.name}_${column.name}" FOREIGN KEY ("${column.name}") REFERENCES "${column.references.table}" ("${column.references.column}")`;
    let constraint = fkDefinition;
    
    if (column.references.onDelete) {
      constraint += ` ON DELETE ${column.references.onDelete}`;
    }
    
    if (column.references.onUpdate) {
      constraint += ` ON UPDATE ${column.references.onUpdate}`;
    }
    
    columnDefinitions.push(constraint);
  });
  
  // Unique constraints
  const uniqueColumns = table.columns.filter(column => column.isUnique && !column.isPrimaryKey);
  uniqueColumns.forEach(column => {
    columnDefinitions.push(`CONSTRAINT "unique_${table.name}_${column.name}" UNIQUE ("${column.name}")`);
  });
  
  const tableDefinition = `-- Table: ${table.name}${table.isWeakEntity ? ' (Weak Entity)' : ''}${table.isLookupTable ? ' (Lookup Table)' : ''}${table.isJunctionTable ? ' (Junction Table)' : ''}
CREATE TABLE IF NOT EXISTS "${table.name}" (
  ${columnDefinitions.join(',\n  ')}
);`;
  
  // Add table and column comments
  const commentStatements = [];
  
  if (table.description) {
    commentStatements.push(`COMMENT ON TABLE "${table.name}" IS '${escapeString(table.description)}';`);
  }
  
  mappedColumns.forEach(column => {
    if (column.description) {
      commentStatements.push(`COMMENT ON COLUMN "${table.name}"."${column.name}" IS '${escapeString(column.description)}';`);
    }
  });
  
  return tableDefinition + '\n\n-- Add table and column comments\n' + commentStatements.join('\n');
};

/**
 * Generate CREATE INDEX statements for PostgreSQL
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {Array} - CREATE INDEX statements
 */
exports.createIndexStatements = (table, schema) => {
  const indexes = [];
  
  // Add indexes for foreign keys
  const foreignKeyColumns = table.columns.filter(column => column.isForeignKey);
  
  foreignKeyColumns.forEach(column => {
    // Skip if the column is already part of the primary key
    if (!column.isPrimaryKey) {
      indexes.push(`-- Index for foreign key: ${column.name}
CREATE INDEX "idx_${table.name}_${column.name}" ON "${table.name}" ("${column.name}");`);
    }
  });
  
  // Add indexes for frequently queried columns
  const potentialIndexColumns = table.columns.filter(col => 
    // Skip columns that already have indexes
    !col.isPrimaryKey && 
    !col.isForeignKey && 
    !col.isUnique &&
    // Target columns likely to be used in WHERE clauses or for sorting
    (col.name.includes('status') || 
     col.name.includes('type') || 
     col.name.includes('date') || 
     col.name.includes('code') ||
     col.name.includes('category') ||
     col.name === 'name' ||
     col.name === 'email')
  );
  
  potentialIndexColumns.forEach(column => {
    indexes.push(`-- Index for commonly queried column: ${column.name}
CREATE INDEX "idx_${table.name}_${column.name}" ON "${table.name}" ("${column.name}");`);
  });
  
  // Add GIN indexes for text columns that might be used for full-text search
  const textColumns = table.columns.filter(col => 
    ['TEXT', 'VARCHAR'].some(type => col.dataType.toUpperCase().includes(type)) &&
    ['description', 'content', 'notes', 'details', 'comments'].some(name => col.name.includes(name))
  );
  
  if (textColumns.length > 0) {
    // Create a single GIN index for multiple text columns if available
    if (textColumns.length > 1) {
      indexes.push(`-- Full-text search index for text columns
CREATE INDEX "idx_${table.name}_fulltext" ON "${table.name}" USING gin(
  ${textColumns.map(col => `to_tsvector('english', "${col.name}")`).join(' || ')}
);

-- Note: For production use, consider using a dedicated tsvector column that is updated via triggers
-- instead of computing the tsvector on-the-fly`);
    } else {
      // Just one text column
      const column = textColumns[0];
      indexes.push(`-- Full-text search index for ${column.name}
CREATE INDEX "idx_${table.name}_${column.name}_fulltext" ON "${table.name}" USING gin(to_tsvector('english', "${column.name}"));`);
    }
  }
  
  return indexes;
};

/**
 * Generate ALTER TABLE statement for adding foreign key
 * @param {string} tableName - Table name
 * @param {Object} foreignKey - Foreign key constraint
 * @returns {string} - ALTER TABLE statement
 */
exports.addForeignKeyStatement = (tableName, foreignKey) => {
  return `ALTER TABLE "${tableName}"
ADD CONSTRAINT "${foreignKey.constraintName || `fk_${tableName}_${foreignKey.columnName}`}"
FOREIGN KEY ("${foreignKey.columnName}")
REFERENCES "${foreignKey.referenceTable}"("${foreignKey.referenceColumn}")
ON DELETE ${foreignKey.onDelete}
ON UPDATE ${foreignKey.onUpdate};`;
};

/**
 * Generate CREATE VIEW statements for commonly needed views
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of CREATE VIEW statements
 */
exports.createViewStatements = (schema) => {
  const views = [];
  
  // Find tables with typical view potential (e.g., join opportunities)
  const tablesWithRelationships = new Set();
  
  // Collect tables involved in relationships
  schema.relationships.forEach(rel => {
    tablesWithRelationships.add(rel.sourceTable);
    tablesWithRelationships.add(rel.targetTable);
  });
  
  // Generate views for tables with many relationships
  Array.from(tablesWithRelationships).forEach(tableName => {
    const table = schema.tables.find(t => t.name === tableName);
    if (!table) return;
    
    // Find all direct relationships for this table
    const relations = schema.relationships.filter(rel => 
      rel.sourceTable === tableName || rel.targetTable === tableName
    );
    
    // Skip if not enough relationships
    if (relations.length < 2) return;
    
    // Create a view that joins this table with its related tables
    const joinClauses = [];
    const selectColumns = [`t."${table.columns.map(c => c.name).join('", t."')}"`];
    
    relations.forEach((rel, idx) => {
      const isSource = rel.sourceTable === tableName;
      const relatedTableName = isSource ? rel.targetTable : rel.sourceTable;
      const relatedTable = schema.tables.find(t => t.name === relatedTableName);
      
      if (!relatedTable) return;
      
      const alias = `r${idx + 1}`;
      
      // Skip junction tables for the view to keep it simpler
      if (relatedTable.isJunctionTable) return;
      
      // Add join clause
      if (isSource) {
        // This table to related table
        joinClauses.push(`LEFT JOIN "${relatedTableName}" ${alias} ON t."${rel.sourceColumn}" = ${alias}."${rel.targetColumn}"`);
      } else {
        // Related table to this table
        joinClauses.push(`LEFT JOIN "${relatedTableName}" ${alias} ON ${alias}."${rel.sourceColumn}" = t."${rel.targetColumn}"`);
      }
      
      // Add columns from related table, except for the join key to avoid duplication
      const relatedColumns = relatedTable.columns
        .filter(c => !(isSource && c.name === rel.targetColumn) && 
                    !(!isSource && c.name === rel.sourceColumn))
        .map(c => `${alias}."${c.name}" AS "${relatedTableName}_${c.name}"`);
      
      selectColumns.push(...relatedColumns);
    });
    
    // Skip if no joins were created
    if (joinClauses.length === 0) return;
    
    // Create the view
    views.push(`-- View for ${tableName} with related data
CREATE OR REPLACE VIEW "v_${tableName}_details" AS
SELECT 
  ${selectColumns.join(',\n  ')}
FROM "${tableName}" t
${joinClauses.join('\n')};

-- Add view comment
COMMENT ON VIEW "v_${tableName}_details" IS 'Detailed view for ${tableName} with joined related data';`);
  });
  
  return views;
};

/**
 * Generate PostgreSQL functions and triggers
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of CREATE FUNCTION and CREATE TRIGGER statements
 */
exports.createTriggerStatements = (schema) => {
  const triggers = [];
  
  // First create the update timestamp function (only once)
  triggers.push(`-- Function to update 'updated_at' timestamp automatically
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';`);
  
  // Now create triggers for each table with updated_at column
  schema.tables.forEach(table => {
    // Check if the table has updated_at column
    const hasUpdatedAt = table.columns.some(col => col.name === 'updated_at');
    
    if (hasUpdatedAt) {
      triggers.push(`-- Trigger for automatic updated_at timestamp on ${table.name}
CREATE TRIGGER trig_${table.name}_update_timestamp
BEFORE UPDATE ON "${table.name}"
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();`);
    }
  });
  
  return triggers;
};

/**
 * Generate seed data for lookup tables
 * @param {Object} table - Table object
 * @returns {Array} - Array of INSERT statements
 */
exports.generateSeedData = (table) => {
  // Only generate seed data for lookup tables
  if (!table.isLookupTable) return [];
  
  // Prepare the insert statement
  let insertStatement = `-- Seed data for lookup table: ${table.name}\nINSERT INTO "${table.name}" (`;
  
  // Find column names, excluding auto-increment primary keys and timestamps
  const columns = table.columns.filter(col => 
    !(col.isPrimaryKey && ['SERIAL', 'BIGSERIAL', 'SMALLSERIAL'].some(type => col.dataType.toUpperCase().includes(type))) &&
    col.name !== 'created_at' && 
    col.name !== 'updated_at'
  );
  
  // If no suitable columns found, return empty array
  if (columns.length === 0) return [];
  
  // Add column names
  insertStatement += columns.map(col => `"${col.name}"`).join(', ');
  insertStatement += ') VALUES\n';
  
  // Generate example values based on table name and column types
  const values = [];
  
  // Determine the type of lookup table and generate appropriate data
  if (table.name.includes('status')) {
    values.push(generateValuesList(columns, ['Active', 'Inactive', 'Pending', 'Completed', 'Cancelled']));
  } else if (table.name.includes('type')) {
    values.push(generateValuesList(columns, ['Standard', 'Premium', 'Basic', 'Custom', 'Enterprise']));
  } else if (table.name.includes('category')) {
    values.push(generateValuesList(columns, ['General', 'Electronics', 'Clothing', 'Food', 'Services']));
  } else if (table.name.includes('priority')) {
    values.push(generateValuesList(columns, ['Low', 'Medium', 'High', 'Critical', 'Urgent']));
  } else if (table.name.includes('role')) {
    values.push(generateValuesList(columns, ['Admin', 'User', 'Manager', 'Guest', 'SuperAdmin']));
  } else {
    // Generic lookup table with sequential values
    values.push(generateValuesList(columns, ['Value 1', 'Value 2', 'Value 3', 'Value 4', 'Value 5']));
  }
  
  // Add values
  insertStatement += values.join(',\n');
  insertStatement += ';';
  
  return [insertStatement];
};

/**
 * Generate a list of values for INSERT statement
 * @param {Array} columns - Columns to generate values for
 * @param {Array} names - Example names to use
 * @returns {string} - VALUES clause for INSERT statement
 */
function generateValuesList(columns, names) {
  const rows = [];
  
  names.forEach((name, idx) => {
    const values = columns.map(col => {
      if (col.name === 'name' || col.name === 'label' || col.name === 'title') {
        return `'${escapeString(name)}'`;
      } else if (col.name === 'code' || col.name === 'key') {
        return `'${name.substring(0, 3).toUpperCase()}'`;
      } else if (col.name === 'value' || col.name === 'id') {
        return idx + 1;
      } else if (col.name === 'description') {
        return `'${escapeString(name)} description'`;
      } else if (col.name === 'is_active' || col.name === 'active') {
        return 'true';
      } else if (col.name === 'display_order' || col.name === 'sort_order') {
        return idx + 1;
      } else if (col.dataType.toUpperCase().includes('INT')) {
        return idx + 1;
      } else {
        return `'Value ${idx + 1}'`;
      }
    });
    
    rows.push(`(${values.join(', ')})`);
  });
  
  return rows.join(',\n');
}

/**
 * Generate footer for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Footer comment
 */
exports.footerComment = (schema) => {
  return `-- Commit the transaction
COMMIT;

-- Script execution completed
-- Schema: ${schema.name}
-- Tables: ${schema.tables.length}`;
};

/**
 * Format default value for PostgreSQL
 * @param {string} value - Default value
 * @param {string} dataType - Column data type
 * @returns {string} - Formatted default value
 */
function formatDefaultValue(value, dataType) {
  if (value === 'CURRENT_TIMESTAMP' || value === 'NOW()') {
    return 'CURRENT_TIMESTAMP';
  } else if (value === 'NULL') {
    return 'NULL';
  } else if (dataType && (
      dataType.toUpperCase().includes('INT') || 
      dataType.toUpperCase().includes('FLOAT') || 
      dataType.toUpperCase().includes('REAL') || 
      dataType.toUpperCase().includes('DECIMAL') ||
      dataType.toUpperCase().includes('NUMERIC')
    ) && !isNaN(value)) {
    // For numeric types, don't quote numeric values
    return value;
  } else if (dataType && dataType.toUpperCase().includes('BOOLEAN')) {
    // Handle boolean values
    if (value.toLowerCase() === 'true' || value === '1' || value.toLowerCase() === 'yes') {
      return 'true';
    } else if (value.toLowerCase() === 'false' || value === '0' || value.toLowerCase() === 'no') {
      return 'false';
    }
  }
  
  // For all other cases, quote the value
  return `'${escapeString(value)}'`;
}

/**
 * Check if table has composite primary key
 * @param {Object} table - Table object
 * @returns {boolean} - True if table has composite primary key
 */
function isCompositePrimaryKey(table) {
  return table.columns.filter(column => column.isPrimaryKey).length > 1;
}

/**
 * Escape string for PostgreSQL
 * @param {string} str - String to escape
 * @returns {string} - Escaped string
 */
function escapeString(str) {
  if (typeof str !== 'string') return str;
  return str.replace(/'/g, "''");
}

/**
 * Map MySQL data types to PostgreSQL data types
 * @param {string} dataType - MySQL data type
 * @returns {string} - PostgreSQL data type
 */
function mapDataType(dataType) {
  if (!dataType) return 'VARCHAR(255)';
  
  const typeMap = {
    'INT': 'INTEGER',
    'INTEGER': 'INTEGER',
    'TINYINT': 'SMALLINT',
    'SMALLINT': 'SMALLINT',
    'MEDIUMINT': 'INTEGER',
    'BIGINT': 'BIGINT',
    'FLOAT': 'REAL',
    'DOUBLE': 'DOUBLE PRECISION',
    'DECIMAL': 'DECIMAL',
    'CHAR': 'CHAR',
    'VARCHAR': 'VARCHAR',
    'TEXT': 'TEXT',
    'TINYTEXT': 'TEXT',
    'MEDIUMTEXT': 'TEXT',
    'LONGTEXT': 'TEXT',
    'BOOLEAN': 'BOOLEAN',
    'BOOL': 'BOOLEAN',
    'DATE': 'DATE',
    'DATETIME': 'TIMESTAMP',
    'TIMESTAMP': 'TIMESTAMP',
    'TIME': 'TIME',
    'YEAR': 'INTEGER',
    'BLOB': 'BYTEA',
    'TINYBLOB': 'BYTEA',
    'MEDIUMBLOB': 'BYTEA',
    'LONGBLOB': 'BYTEA',
    'ENUM': 'VARCHAR',
    'SET': 'VARCHAR',
    'JSON': 'JSONB',  // PostgreSQL's native JSON type
    'UUID': 'UUID'    // PostgreSQL's native UUID type
  };
  
  // Extract type and size
  const match = dataType.match(/^(\w+)(?:\(([^)]+)\))?$/);
  if (!match) return dataType;
  
  const type = match[1].toUpperCase();
  const size = match[2];
  
  // Map the type
  const baseType = typeMap[type] || type;
  
  // Add the size if applicable
  if (size && (baseType === 'VARCHAR' || baseType === 'CHAR' || baseType === 'DECIMAL')) {
    return `${baseType}(${size})`;
  }
  
  return baseType;
}

module.exports = exports;
