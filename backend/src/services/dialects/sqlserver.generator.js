/**
 * SQL Server (Microsoft SQL Server) Generator
 * Enhanced version with support for additional features
 */

/**
 * Generate a header comment for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Header comment
 */
exports.headerComment = (schema) => {
  return `-- SQL Server Script Generated for Schema: ${schema.name}
-- Created: ${new Date().toISOString()}
-- Description: ${schema.description || 'Database schema generated by LaymanDB'}

-- Set NOCOUNT ON to reduce network traffic
SET NOCOUNT ON;

-- Create a new database if it doesn't exist
IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = N'${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}')
BEGIN
    CREATE DATABASE [${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}];
END
GO

USE [${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}];
GO

-- Enable snapshot isolation for better concurrency
ALTER DATABASE [${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}] SET ALLOW_SNAPSHOT_ISOLATION ON;
GO

-- Set recovery model to simple for better performance (change to FULL for production)
ALTER DATABASE [${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}] SET RECOVERY SIMPLE;
GO`;
};

/**
 * Generate DROP statements for all tables to allow re-running the script
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of DROP TABLE statements
 */
exports.generateDropStatements = (schema) => {
  return [`-- Drop foreign key constraints first
${schema.tables.map(table => {
  const foreignKeyColumns = table.columns.filter(col => col.isForeignKey && col.references);
  if (foreignKeyColumns.length === 0) return '';
  
  return foreignKeyColumns.map(col => `
IF OBJECT_ID(N'[dbo].[FK_${table.name}_${col.name}]', N'F') IS NOT NULL
    ALTER TABLE [dbo].[${table.name}] DROP CONSTRAINT [FK_${table.name}_${col.name}];`).join('');
}).filter(Boolean).join('\n')}

-- Drop tables if they exist
${schema.tables.map(table => `
IF OBJECT_ID(N'[dbo].[${table.name}]', N'U') IS NOT NULL
    DROP TABLE [dbo].[${table.name}];`).join('')}
GO`];
};

/**
 * Generate CREATE TABLE statement for SQL Server
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {string} - CREATE TABLE statement
 */
exports.createTableStatement = (table, schema) => {
  // Map MySQL data types to SQL Server
  const mappedColumns = table.columns.map(column => ({
    ...column,
    dataType: mapDataType(column.dataType)
  }));
  
  const columnDefinitions = mappedColumns.map(column => {
    let definition = `[${column.name}] ${column.dataType}`;
    
    // Handle identity for primary keys (SQL Server's auto-increment)
    if (column.isPrimaryKey && 
        !isCompositePrimaryKey(table) && 
        ['INT', 'BIGINT', 'SMALLINT', 'TINYINT'].includes(column.dataType.toUpperCase())) {
      definition += ' IDENTITY(1,1)';
    }
    
    if (column.isNullable === false) {
      definition += ' NOT NULL';
    } else {
      definition += ' NULL';
    }
    
    if (column.defaultValue) {
      definition += ` DEFAULT ${formatDefaultValue(column.defaultValue, column.dataType)}`;
    }
    
    if (column.isPrimaryKey && !isCompositePrimaryKey(table)) {
      definition += ' PRIMARY KEY';
    }
    
    return definition;
  });
  
  // Handle composite primary keys
  const primaryKeyColumns = table.columns.filter(column => column.isPrimaryKey);
  if (primaryKeyColumns.length > 1) {
    const pkDefinition = `CONSTRAINT [PK_${table.name}] PRIMARY KEY (${primaryKeyColumns.map(col => `[${col.name}]`).join(', ')})`;
    columnDefinitions.push(pkDefinition);
  }
  
  // SQL Server doesn't support inline foreign key constraints in CREATE TABLE
  // We'll use ALTER TABLE statements for these
  
  // Unique constraints
  const uniqueColumns = table.columns.filter(column => column.isUnique && !column.isPrimaryKey);
  uniqueColumns.forEach(column => {
    columnDefinitions.push(`CONSTRAINT [UQ_${table.name}_${column.name}] UNIQUE ([${column.name}])`);
  });
  
  // Include table type in comment for clarity
  let tableType = '';
  if (table.isWeakEntity) tableType += ' (Weak Entity)';
  if (table.isLookupTable) tableType += ' (Lookup Table)';
  if (table.isJunctionTable) tableType += ' (Junction Table)';
  
  // Table declaration
  const tableDefinition = `-- Table: ${table.name}${tableType}
IF OBJECT_ID(N'[dbo].[${table.name}]', N'U') IS NULL
BEGIN
CREATE TABLE [dbo].[${table.name}] (
  ${columnDefinitions.join(',\n  ')}
);`;
  
  // Add extended properties for table and column descriptions
  const extendedProperties = [];
  
  if (table.description) {
    extendedProperties.push(`
-- Add table description
EXEC sys.sp_addextendedproperty 
  @name = N'Description', 
  @value = N'${escapeString(table.description)}',
  @level0type = N'SCHEMA', @level0name = N'dbo',
  @level1type = N'TABLE',  @level1name = N'${table.name}';`);
  }
  
  // Add column descriptions
  mappedColumns.forEach(column => {
    if (column.description) {
      extendedProperties.push(`
-- Add column description for ${column.name}
EXEC sys.sp_addextendedproperty 
  @name = N'Description', 
  @value = N'${escapeString(column.description)}',
  @level0type = N'SCHEMA', @level0name = N'dbo',
  @level1type = N'TABLE',  @level1name = N'${table.name}',
  @level2type = N'COLUMN', @level2name = N'${column.name}';`);
    }
  });
  
  // Close the IF BEGIN block
  const closingBlock = `
END
GO`;
  
  return tableDefinition + extendedProperties.join('') + closingBlock;
};

/**
 * Generate CREATE INDEX statements for SQL Server
 * @param {Object} table - Table object
 * @param {Object} schema - Full schema
 * @returns {Array} - CREATE INDEX statements
 */
exports.createIndexStatements = (table, schema) => {
  const indexes = [];
  
  // Add indexes for foreign keys
  const foreignKeyColumns = table.columns.filter(column => column.isForeignKey);
  
  foreignKeyColumns.forEach(column => {
    // Skip if the column is already part of the primary key
    if (!column.isPrimaryKey) {
      indexes.push(`-- Index for foreign key: ${column.name}
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = N'IX_${table.name}_${column.name}' 
  AND object_id = OBJECT_ID(N'[dbo].[${table.name}]'))
BEGIN
  CREATE INDEX [IX_${table.name}_${column.name}] ON [dbo].[${table.name}] ([${column.name}]);
END
GO`);
    }
  });
  
  // Add indexes for frequently queried columns
  const potentialIndexColumns = table.columns.filter(col => 
    // Skip columns that already have indexes
    !col.isPrimaryKey && 
    !col.isForeignKey && 
    !col.isUnique &&
    // Target columns likely to be used in WHERE clauses or for sorting
    (col.name.includes('status') || 
     col.name.includes('type') || 
     col.name.includes('date') || 
     col.name.includes('code') ||
     col.name.includes('category') ||
     col.name === 'name' ||
     col.name === 'email')
  );
  
  potentialIndexColumns.forEach(column => {
    indexes.push(`-- Index for commonly queried column: ${column.name}
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = N'IX_${table.name}_${column.name}' 
  AND object_id = OBJECT_ID(N'[dbo].[${table.name}]'))
BEGIN
  CREATE INDEX [IX_${table.name}_${column.name}] ON [dbo].[${table.name}] ([${column.name}]);
END
GO`);
  });
  
  // Consider full-text indexes for text columns
  const textColumns = table.columns.filter(col => 
    ['NVARCHAR', 'VARCHAR', 'TEXT'].some(type => col.dataType.toUpperCase().includes(type)) &&
    ['description', 'content', 'notes', 'details', 'comments'].some(name => col.name.includes(name))
  );
  
  if (textColumns.length > 0) {
    indexes.push(`-- Consider creating a full-text index for text columns in ${table.name}
-- Example full-text catalog and index creation:
/*
IF NOT EXISTS (SELECT * FROM sys.fulltext_catalogs WHERE name = N'FTCatalog_${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}')
  CREATE FULLTEXT CATALOG [FTCatalog_${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}] WITH ACCENT_SENSITIVITY = OFF;

IF NOT EXISTS (SELECT * FROM sys.fulltext_indexes WHERE object_id = OBJECT_ID(N'[dbo].[${table.name}]'))
  CREATE FULLTEXT INDEX ON [dbo].[${table.name}] (
    [${textColumns.map(col => col.name).join('], [')}]
  ) KEY INDEX [PK_${table.name}] ON [FTCatalog_${schema.name.replace(/[^a-zA-Z0-9_]/g, '_')}];
*/
-- Note: Uncomment the above code if full-text search is needed
GO`);
  }
  
  return indexes;
};

/**
 * Generate ALTER TABLE statement for adding foreign key
 * @param {string} tableName - Table name
 * @param {Object} foreignKey - Foreign key constraint
 * @returns {string} - ALTER TABLE statement
 */
exports.addForeignKeyStatement = (tableName, foreignKey) => {
  return `-- Add foreign key constraint
IF OBJECT_ID(N'[dbo].[${foreignKey.constraintName || `FK_${tableName}_${foreignKey.columnName}`}]', N'F') IS NULL
BEGIN
  ALTER TABLE [dbo].[${tableName}]
  ADD CONSTRAINT [${foreignKey.constraintName || `FK_${tableName}_${foreignKey.columnName}`}]
  FOREIGN KEY ([${foreignKey.columnName}])
  REFERENCES [dbo].[${foreignKey.referenceTable}]([${foreignKey.referenceColumn}])
  ON DELETE ${foreignKey.onDelete}
  ON UPDATE ${foreignKey.onUpdate};
END
GO`;
};

/**
 * Generate CREATE VIEW statements for commonly needed views
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of CREATE VIEW statements
 */
exports.createViewStatements = (schema) => {
  const views = [];
  
  // Find tables with typical view potential (e.g., join opportunities)
  const tablesWithRelationships = new Set();
  
  // Collect tables involved in relationships
  schema.relationships.forEach(rel => {
    tablesWithRelationships.add(rel.sourceTable);
    tablesWithRelationships.add(rel.targetTable);
  });
  
  // Generate views for tables with many relationships
  Array.from(tablesWithRelationships).forEach(tableName => {
    const table = schema.tables.find(t => t.name === tableName);
    if (!table) return;
    
    // Find all direct relationships for this table
    const relations = schema.relationships.filter(rel => 
      rel.sourceTable === tableName || rel.targetTable === tableName
    );
    
    // Skip if not enough relationships
    if (relations.length < 2) return;
    
    // Create a view that joins this table with its related tables
    const joinClauses = [];
    const selectColumns = [`t.[${table.columns.map(c => c.name).join('], t.[').replace(/]/g, ']').replace(/\[/g, '[')}]`];
    
    relations.forEach((rel, idx) => {
      const isSource = rel.sourceTable === tableName;
      const relatedTableName = isSource ? rel.targetTable : rel.sourceTable;
      const relatedTable = schema.tables.find(t => t.name === relatedTableName);
      
      if (!relatedTable) return;
      
      const alias = `r${idx + 1}`;
      
      // Skip junction tables for the view to keep it simpler
      if (relatedTable.isJunctionTable) return;
      
      // Add join clause
      if (isSource) {
        // This table to related table
        joinClauses.push(`LEFT JOIN [dbo].[${relatedTableName}] ${alias} ON t.[${rel.sourceColumn}] = ${alias}.[${rel.targetColumn}]`);
      } else {
        // Related table to this table
        joinClauses.push(`LEFT JOIN [dbo].[${relatedTableName}] ${alias} ON ${alias}.[${rel.sourceColumn}] = t.[${rel.targetColumn}]`);
      }
      
      // Add columns from related table, except for the join key to avoid duplication
      const relatedColumns = relatedTable.columns
        .filter(c => !(isSource && c.name === rel.targetColumn) && 
                    !(!isSource && c.name === rel.sourceColumn))
        .map(c => `${alias}.[${c.name}] AS [${relatedTableName}_${c.name}]`);
      
      selectColumns.push(...relatedColumns);
    });
    
    // Skip if no joins were created
    if (joinClauses.length === 0) return;
    
    // Create the view
    views.push(`-- View for ${tableName} with related data
IF OBJECT_ID(N'[dbo].[v_${tableName}_details]', N'V') IS NULL
BEGIN
  EXEC('
  CREATE VIEW [dbo].[v_${tableName}_details] AS
  SELECT 
    ${selectColumns.join(',\n    ')}
  FROM [dbo].[${tableName}] t
  ${joinClauses.join('\n  ')}
  ');

  -- Add view description
  EXEC sys.sp_addextendedproperty 
    @name = N''Description'', 
    @value = N''Detailed view for ${tableName} with joined related data'',
    @level0type = N''SCHEMA'', @level0name = N''dbo'',
    @level1type = N''VIEW'',  @level1name = N''v_${tableName}_details'';
END
GO`);
  });
  
  return views;
};

/**
 * Generate stored procedures for common operations
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of CREATE PROCEDURE statements
 */
exports.createStoredProcedures = (schema) => {
  const procedures = [];
  
  // Create stored procedures for each table
  schema.tables.forEach(table => {
    // Skip junction tables for stored procedures
    if (table.isJunctionTable) return;
    
    // Get columns excluding timestamps and identity columns if primary key
    const insertableColumns = table.columns.filter(col => 
      col.name !== 'created_at' && 
      col.name !== 'updated_at' &&
      !(col.isPrimaryKey && ['INT', 'BIGINT', 'SMALLINT', 'TINYINT'].some(
        type => col.dataType.toUpperCase().includes(type)))
    );
    
    // Get all updatable columns (exclude primary keys)
    const updatableColumns = table.columns.filter(col => 
      !col.isPrimaryKey && 
      col.name !== 'created_at'
    );
    
    // Create CRUD stored procedures
    
    // CREATE procedure
    procedures.push(`-- Create stored procedure for inserting a new ${table.name}
IF OBJECT_ID(N'[dbo].[sp_${table.name}_Create]', N'P') IS NULL
BEGIN
  EXEC('
  CREATE PROCEDURE [dbo].[sp_${table.name}_Create]
    ${insertableColumns.map(col => `@${col.name} ${col.dataType}${col.isNullable ? ' = NULL' : ''}`).join(',\n    ')}${
      updatableColumns.some(col => col.name === 'updated_at') ? ',\n    @updated_at DATETIME = NULL' : ''
    }
  AS
  BEGIN
    SET NOCOUNT ON;
    
    INSERT INTO [dbo].[${table.name}] (
      ${insertableColumns.map(col => `[${col.name}]`).join(',\n      ')}${
        table.columns.some(col => col.name === 'created_at') ? ',\n      [created_at]' : ''
      }${
        updatableColumns.some(col => col.name === 'updated_at') ? ',\n      [updated_at]' : ''
      }
    )
    VALUES (
      ${insertableColumns.map(col => `@${col.name}`).join(',\n      ')}${
        table.columns.some(col => col.name === 'created_at') ? ',\n      GETDATE()' : ''
      }${
        updatableColumns.some(col => col.name === 'updated_at') ? ',\n      ISNULL(@updated_at, GETDATE())' : ''
      }
    );
    
    -- Return the newly created record ID
    ${table.columns.some(col => col.isPrimaryKey) ? 
      'SELECT SCOPE_IDENTITY() AS [id];' : 
      '-- No primary key defined for this table'}
  END
  ');
  
  -- Add procedure description
  EXEC sys.sp_addextendedproperty 
    @name = N'Description', 
    @value = N'Creates a new record in the ${table.name} table',
    @level0type = N'SCHEMA', @level0name = N'dbo',
    @level1type = N'PROCEDURE',  @level1name = N'sp_${table.name}_Create';
END
GO`);
    
    // Only create the rest of the CRUD procedures if there's a primary key
    const primaryKey = table.columns.find(col => col.isPrimaryKey);
    if (primaryKey) {
      // READ procedure
      procedures.push(`-- Create stored procedure for retrieving a ${table.name} by ID
IF OBJECT_ID(N'[dbo].[sp_${table.name}_GetById]', N'P') IS NULL
BEGIN
  EXEC('
  CREATE PROCEDURE [dbo].[sp_${table.name}_GetById]
    @${primaryKey.name} ${primaryKey.dataType}
  AS
  BEGIN
    SET NOCOUNT ON;
    
    SELECT *
    FROM [dbo].[${table.name}]
    WHERE [${primaryKey.name}] = @${primaryKey.name};
  END
  ');
  
  -- Add procedure description
  EXEC sys.sp_addextendedproperty 
    @name = N'Description', 
    @value = N'Retrieves a ${table.name} record by ID',
    @level0type = N'SCHEMA', @level0name = N'dbo',
    @level1type = N'PROCEDURE',  @level1name = N'sp_${table.name}_GetById';
END
GO`);
      
      // UPDATE procedure
      if (updatableColumns.length > 0) {
        procedures.push(`-- Create stored procedure for updating a ${table.name}
IF OBJECT_ID(N'[dbo].[sp_${table.name}_Update]', N'P') IS NULL
BEGIN
  EXEC('
  CREATE PROCEDURE [dbo].[sp_${table.name}_Update]
    @${primaryKey.name} ${primaryKey.dataType},
    ${updatableColumns.map(col => `@${col.name} ${col.dataType}${col.isNullable ? ' = NULL' : ''}`).join(',\n    ')}
  AS
  BEGIN
    SET NOCOUNT ON;
    
    UPDATE [dbo].[${table.name}]
    SET 
      ${updatableColumns.map(col => {
        if (col.name === 'updated_at') {
          return `[${col.name}] = GETDATE()`;
        } else {
          return `[${col.name}] = @${col.name}`;
        }
      }).join(',\n      ')}
    WHERE [${primaryKey.name}] = @${primaryKey.name};
    
    -- Return 1 if successful
    SELECT @@ROWCOUNT AS [RowsAffected];
  END
  ');
  
  -- Add procedure description
  EXEC sys.sp_addextendedproperty 
    @name = N'Description', 
    @value = N'Updates a ${table.name} record',
    @level0type = N'SCHEMA', @level0name = N'dbo',
    @level1type = N'PROCEDURE',  @level1name = N'sp_${table.name}_Update';
END
GO`);
      }
      
      // DELETE procedure
      procedures.push(`-- Create stored procedure for deleting a ${table.name}
IF OBJECT_ID(N'[dbo].[sp_${table.name}_Delete]', N'P') IS NULL
BEGIN
  EXEC('
  CREATE PROCEDURE [dbo].[sp_${table.name}_Delete]
    @${primaryKey.name} ${primaryKey.dataType}
  AS
  BEGIN
    SET NOCOUNT ON;
    
    DELETE FROM [dbo].[${table.name}]
    WHERE [${primaryKey.name}] = @${primaryKey.name};
    
    -- Return 1 if successful
    SELECT @@ROWCOUNT AS [RowsAffected];
  END
  ');
  
  -- Add procedure description
  EXEC sys.sp_addextendedproperty 
    @name = N'Description', 
    @value = N'Deletes a ${table.name} record',
    @level0type = N'SCHEMA', @level0name = N'dbo',
    @level1type = N'PROCEDURE',  @level1name = N'sp_${table.name}_Delete';
END
GO`);
      
      // LIST procedure
      procedures.push(`-- Create stored procedure for listing ${table.name} records with paging
IF OBJECT_ID(N'[dbo].[sp_${table.name}_List]', N'P') IS NULL
BEGIN
  EXEC('
  CREATE PROCEDURE [dbo].[sp_${table.name}_List]
    @PageNumber INT = 1,
    @PageSize INT = 20,
    @SortColumn NVARCHAR(128) = ''${primaryKey.name}'',
    @SortDirection NVARCHAR(4) = ''ASC''
  AS
  BEGIN
    SET NOCOUNT ON;
    
    -- Validate inputs
    SET @PageNumber = ISNULL(@PageNumber, 1);
    SET @PageSize = ISNULL(@PageSize, 20);
    
    -- Calculate the starting row for pagination
    DECLARE @StartRow INT = (@PageNumber - 1) * @PageSize + 1;
    DECLARE @EndRow INT = @PageNumber * @PageSize;
    
    -- Get total count for pagination info
    DECLARE @TotalCount INT;
    SELECT @TotalCount = COUNT(*) FROM [dbo].[${table.name}];
    
    -- Construct the dynamic SQL for sorting
    DECLARE @SQL NVARCHAR(MAX);
    SET @SQL = N''
      WITH PaginatedData AS (
        SELECT *,
          ROW_NUMBER() OVER (ORDER BY '' + QUOTENAME(@SortColumn) + '' '' + @SortDirection + '') AS RowNum
        FROM [dbo].[${table.name}]
      )
      SELECT *
      FROM PaginatedData
      WHERE RowNum BETWEEN '' + CAST(@StartRow AS NVARCHAR(10)) + '' AND '' + CAST(@EndRow AS NVARCHAR(10)) + '';
      
      SELECT @TotalCount AS TotalCount, 
             '' + CAST(@PageNumber AS NVARCHAR(10)) + '' AS PageNumber, 
             '' + CAST(@PageSize AS NVARCHAR(10)) + '' AS PageSize,
             '' + CAST(CEILING((@TotalCount * 1.0) / @PageSize) AS NVARCHAR(10)) + '' AS TotalPages;
    '';
    
    -- Execute the dynamic SQL
    EXEC sp_executesql @SQL, N''@TotalCount INT'', @TotalCount;
  END
  ');
  
  -- Add procedure description
  EXEC sys.sp_addextendedproperty 
    @name = N'Description', 
    @value = N'Lists ${table.name} records with paging and sorting',
    @level0type = N'SCHEMA', @level0name = N'dbo',
    @level1type = N'PROCEDURE',  @level1name = N'sp_${table.name}_List';
END
GO`);
    }
  });
  
  return procedures;
};

/**
 * Generate SQL Server triggers
 * @param {Object} schema - Database schema
 * @returns {Array} - Array of CREATE TRIGGER statements
 */
exports.createTriggerStatements = (schema) => {
  const triggers = [];
  
  schema.tables.forEach(table => {
    // Check if the table has updated_at column
    const hasUpdatedAt = table.columns.some(col => col.name === 'updated_at');
    
    if (hasUpdatedAt) {
      triggers.push(`-- Trigger for automatic updated_at timestamp on ${table.name}
IF OBJECT_ID(N'[dbo].[TR_${table.name}_UpdateTimestamp]', N'TR') IS NULL
BEGIN
  EXEC('
  CREATE TRIGGER [dbo].[TR_${table.name}_UpdateTimestamp]
  ON [dbo].[${table.name}]
  AFTER UPDATE
  AS
  BEGIN
    SET NOCOUNT ON;
    
    IF NOT UPDATE([updated_at])
    BEGIN
      UPDATE [dbo].[${table.name}]
      SET [updated_at] = GETDATE()
      FROM [dbo].[${table.name}] t
      INNER JOIN inserted i ON t.[${table.columns.find(col => col.isPrimaryKey)?.name || 'id'}] = i.[${table.columns.find(col => col.isPrimaryKey)?.name || 'id'}];
    END
  END
  ');
END
GO`);
    }
  });
  
  return triggers;
};

/**
 * Generate seed data for lookup tables
 * @param {Object} table - Table object
 * @returns {Array} - Array of INSERT statements
 */
exports.generateSeedData = (table) => {
  // Only generate seed data for lookup tables
  if (!table.isLookupTable) return [];
  
  // Prepare the insert statement
  let insertStatement = `-- Seed data for lookup table: ${table.name}
IF NOT EXISTS (SELECT TOP 1 1 FROM [dbo].[${table.name}])
BEGIN
    INSERT INTO [dbo].[${table.name}] (`;
  
  // Find column names, excluding identity columns and timestamps
  const columns = table.columns.filter(col => 
    !(col.isPrimaryKey && ['INT', 'BIGINT', 'SMALLINT', 'TINYINT'].some(
      type => col.dataType.toUpperCase().includes(type))) &&
    col.name !== 'created_at' && 
    col.name !== 'updated_at'
  );
  
  // If no suitable columns found, return empty array
  if (columns.length === 0) return [];
  
  // Add column names
  insertStatement += columns.map(col => `[${col.name}]`).join(', ');
  insertStatement += ') VALUES\n';
  
  // Generate example values based on table name and column types
  const values = [];
  
  // Determine the type of lookup table and generate appropriate data
  if (table.name.includes('status')) {
    values.push(generateValuesList(columns, ['Active', 'Inactive', 'Pending', 'Completed', 'Cancelled']));
  } else if (table.name.includes('type')) {
    values.push(generateValuesList(columns, ['Standard', 'Premium', 'Basic', 'Custom', 'Enterprise']));
  } else if (table.name.includes('category')) {
    values.push(generateValuesList(columns, ['General', 'Electronics', 'Clothing', 'Food', 'Services']));
  } else if (table.name.includes('priority')) {
    values.push(generateValuesList(columns, ['Low', 'Medium', 'High', 'Critical', 'Urgent']));
  } else if (table.name.includes('role')) {
    values.push(generateValuesList(columns, ['Admin', 'User', 'Manager', 'Guest', 'SuperAdmin']));
  } else {
    // Generic lookup table with sequential values
    values.push(generateValuesList(columns, ['Value 1', 'Value 2', 'Value 3', 'Value 4', 'Value 5']));
  }
  
  // Add values
  insertStatement += values.join(',\n');
  insertStatement += ';';
  
  return [`${insertStatement}\nEND\nGO`];
};

/**
 * Generate a list of values for INSERT statement
 * @param {Array} columns - Columns to generate values for
 * @param {Array} names - Example names to use
 * @returns {string} - VALUES clause for INSERT statement
 */
function generateValuesList(columns, names) {
  const rows = [];
  
  names.forEach((name, idx) => {
    const values = columns.map(col => {
      if (col.name === 'name' || col.name === 'label' || col.name === 'title') {
        return `N'${escapeString(name)}'`;
      } else if (col.name === 'code' || col.name === 'key') {
        return `N'${name.substring(0, 3).toUpperCase()}'`;
      } else if (col.name === 'value' || col.name === 'id') {
        return idx + 1;
      } else if (col.name === 'description') {
        return `N'${escapeString(name)} description'`;
      } else if (col.name === 'is_active' || col.name === 'active') {
        return '1';
      } else if (col.name === 'display_order' || col.name === 'sort_order') {
        return idx + 1;
      } else if (col.dataType.toUpperCase().includes('INT')) {
        return idx + 1;
      } else if (col.dataType.toUpperCase().includes('DATETIME')) {
        return 'GETDATE()';
      } else {
        return `N'Value ${idx + 1}'`;
      }
    });
    
    rows.push(`(${values.join(', ')})`);
  });
  
  return rows.join(',\n');
}

/**
 * Generate footer for the SQL script
 * @param {Object} schema - Database schema
 * @returns {string} - Footer comment
 */
exports.footerComment = (schema) => {
  return `-- Script execution completed
-- Schema: ${schema.name}
-- Tables: ${schema.tables.length}
GO`;
};

/**
 * Format default value for SQL Server
 * @param {string} value - Default value
 * @param {string} dataType - Column data type
 * @returns {string} - Formatted default value
 */
function formatDefaultValue(value, dataType) {
  if (!value) return null;
  
  if (value === 'CURRENT_TIMESTAMP' || value === 'NOW()') {
    return 'GETDATE()';
  } else if (value === 'NULL') {
    return 'NULL';
  } else if (dataType && (
      dataType.toUpperCase().includes('INT') || 
      dataType.toUpperCase().includes('FLOAT') || 
      dataType.toUpperCase().includes('REAL') || 
      dataType.toUpperCase().includes('DECIMAL') ||
      dataType.toUpperCase().includes('NUMERIC') ||
      dataType.toUpperCase().includes('MONEY')
    ) && !isNaN(value)) {
    // For numeric types, don't quote numeric values
    return value;
  } else if (dataType && dataType.toUpperCase().includes('BIT')) {
    // Handle boolean values for BIT type
    if (value.toLowerCase() === 'true' || value === '1' || value.toLowerCase() === 'yes') {
      return '1';
    } else if (value.toLowerCase() === 'false' || value === '0' || value.toLowerCase() === 'no') {
      return '0';
    }
  }
  
  // For all other cases, quote the value
  return `N'${escapeString(value)}'`;
}

/**
 * Escape string for SQL Server
 * @param {string} str - String to escape
 * @returns {string} - Escaped string
 */
function escapeString(str) {
  if (typeof str !== 'string') return str;
  return str.replace(/'/g, "''");
}

/**
 * Check if table has composite primary key
 * @param {Object} table - Table object
 * @returns {boolean} - True if table has composite primary key
 */
function isCompositePrimaryKey(table) {
  return table.columns.filter(column => column.isPrimaryKey).length > 1;
}

/**
 * Map MySQL data types to SQL Server data types
 * @param {string} dataType - MySQL data type
 * @returns {string} - SQL Server data type
 */
function mapDataType(dataType) {
  if (!dataType) return 'NVARCHAR(255)';
  
  const typeMap = {
    'INT': 'INT',
    'INTEGER': 'INT',
    'TINYINT': 'TINYINT',
    'SMALLINT': 'SMALLINT',
    'MEDIUMINT': 'INT',
    'BIGINT': 'BIGINT',
    'FLOAT': 'FLOAT',
    'DOUBLE': 'FLOAT',
    'DECIMAL': 'DECIMAL',
    'CHAR': 'CHAR',
    'VARCHAR': 'NVARCHAR',
    'TEXT': 'NVARCHAR(MAX)',
    'TINYTEXT': 'NVARCHAR(255)',
    'MEDIUMTEXT': 'NVARCHAR(MAX)',
    'LONGTEXT': 'NVARCHAR(MAX)',
    'BOOLEAN': 'BIT',
    'BOOL': 'BIT',
    'DATE': 'DATE',
    'DATETIME': 'DATETIME2',
    'TIMESTAMP': 'DATETIME2',
    'TIME': 'TIME',
    'YEAR': 'INT',
    'BLOB': 'VARBINARY(MAX)',
    'TINYBLOB': 'VARBINARY(255)',
    'MEDIUMBLOB': 'VARBINARY(MAX)',
    'LONGBLOB': 'VARBINARY(MAX)',
    'ENUM': 'NVARCHAR(255)',
    'SET': 'NVARCHAR(255)',
    'JSON': 'NVARCHAR(MAX)',  // SQL Server doesn't have a native JSON type
    'UUID': 'UNIQUEIDENTIFIER'
  };
  
  // Extract type and size
  const match = dataType.match(/^(\w+)(?:\(([^)]+)\))?$/);
  if (!match) return 'NVARCHAR(255)';
  
  const type = match[1].toUpperCase();
  const size = match[2];
  
  // Map the type
  const baseType = typeMap[type] || type;
  
  // Add the size if applicable
  if (size && (baseType === 'NVARCHAR' || baseType === 'VARCHAR' || baseType === 'CHAR' || baseType === 'NCHAR' || baseType === 'DECIMAL')) {
    return `${baseType}(${size})`;
  }
  
  return baseType;
}

module.exports = exports;
